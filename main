#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <time.h>
#include <windows.h>

#include "structures.h"
#include "affichage.h"
#include "moteur.h"
#include "sauvegarde.h"

// Prototypes locaux
void saisirPseudo(char* buffer, int longueurMax);
int jouerNiveau(Partie* partie);
void lancerJeu(Partie* partie);

// === FONCTION DE SAISIE SÉCURISÉE ===
// Source : Assistant IA (Alternative sécurisée à scanf pour l'interface graphique)
// Rôle : Permet de taper son pseudo sans faire planter l'affichage graphique.
// Entrée : Le tableau où stocker le texte (buffer) et sa taille max.
// Sortie : Aucune (modifie directement le buffer).
void saisirPseudo(char* buffer, int longueurMax) {
    int i = 0;
    char c;
    memset(buffer, 0, longueurMax); // On vide le buffer
    while (1) {
        c = getch(); // Lit une touche sans attendre "Entrée"
        if (c == 13) break; // Touche Entrée validée
        else if (c == 8) { // Touche Retour Arrière
            if (i > 0) { i--; printf("\b \b"); buffer[i] = '\0'; }
        }
        else if (i < longueurMax - 1 && c >= 32 && c <= 126) {
            buffer[i] = c; i++; printf("%c", c);
        }
    }
}

// === MAIN ===
// Rôle : Initialise le programme et gère la boucle du Menu Principal.
int main() {
    Partie partie;
    int continuer = 1;
    char pseudo[50];

    // Configure la console pour afficher les accents et émojis (UTF-8)
    // Source : Assistant IA (Configuration Windows)
    system("chcp 65001 > nul");

    while (continuer) {
        afficherMenuPrincipal();
        char touche = getch();

        switch (touche) {
            case '1': // Afficher les règles
                afficherRegles();
                getch();
                break;

            case '2': // Nouvelle Partie
                initialiserPartie(&partie);
                lancerJeu(&partie);
                break;

            case '3': // Charger une partie
                effacerEcran();
            changerCouleur(COULEUR_CYAN);
            printf("\n  >> Entrez votre pseudo pour charger : ");
            changerCouleur(COULEUR_BLANC);

            saisirPseudo(pseudo, 50);

            // 1. On essaie d'abord de charger une sauvegarde "en cours" (complète)
            if (chargerPartieComplete(pseudo, &partie)) {
                printf("\n\n  >> Partie suspendue retrouvee ! (Niveau %d, %ds restants)",
                       partie.niveau, partie.temps_restant);
                Sleep(1500);
                // Pas besoin de genererNiveau, car 'partie' contient déjà le plateau sauvegardé !
                lancerJeu(&partie);
            }
            // 2. Sinon, on cherche une sauvegarde classique (début de niveau)
            else if (chargerPartie(pseudo, &partie.niveau, &partie.vies)) {
                printf("\n\n  >> Progression retrouvee ! (Niveau %d, %d Vies)",
                       partie.niveau, partie.vies);
                Sleep(1500);
                genererNiveau(&partie, partie.niveau);
                lancerJeu(&partie);
            }
            else {
                printf("\n\n  >> Aucune sauvegarde trouvée pour ce pseudo.");
                Sleep(2000);
            }
            break;

            case '4': // Quitter
                continuer = 0;
                break;
        }
    }

    effacerEcran();
    changerCouleur(COULEUR_VERT);
    printf("\n\n    Merci d'avoir joué à ECE HEROES !\n\n");
    changerCouleur(COULEUR_RESET);
    return 0;
}

// === GESTIONNAIRE DE JEU ===
// Rôle : Gère l'enchaînement des niveaux (1 -> 2 -> 3) et la sauvegarde entre eux.
// Entrée : La structure Partie (pointeur).
void lancerJeu(Partie* partie) {
    char pseudo[50];

    // Tant que le joueur est vivant et n'a pas fini le jeu
    while (partie->vies > 0 && partie->niveau <= NB_NIVEAUX) {

        // On lance la boucle de jeu temps réel pour ce niveau
        int resultat = jouerNiveau(partie);

        // CAS 1 : VICTOIRE
        if (resultat == 1) {
            if (partie->niveau < NB_NIVEAUX) {
                afficherVictoire();

                // Proposition de sauvegarde
                effacerEcran();
                changerCouleur(COULEUR_VERT);
                printf("\n\n    NIVEAU %d REUSSI !", partie->niveau);
                changerCouleur(COULEUR_JAUNE);
                printf("\n\n    Voulez-vous sauvegarder ? (O/N) : ");

                char choix = getch();
                if (choix == 'o' || choix == 'O') {
                    changerCouleur(COULEUR_CYAN);
                    printf("\n    Entrez un pseudo : ");
                    changerCouleur(COULEUR_BLANC);
                    saisirPseudo(pseudo, 50);

                    // On sauvegarde la progression (Niveau suivant)
                    sauvegarderPartie(pseudo, partie->niveau + 1, partie->vies);

                    changerCouleur(COULEUR_VERT);
                    printf("\n    Sauvegarde effectuée !");
                    Sleep(1000);
                }
            }

            // Passage au niveau suivant ou Fin du jeu
            if (partie->niveau == NB_NIVEAUX) {
                afficherEcranFinJeu();
                break;
            } else {
                partie->niveau++;
                effacerEcran();
                changerCouleur(COULEUR_VERT);
                printf("\n\n    PASSAGE AU NIVEAU %d\n", partie->niveau);
                Sleep(1500);
                genererNiveau(partie, partie->niveau);
            }
        }
        // CAS 2 : ABANDON (Touche Echap)
        else if (resultat == -1) {
            break;
        }
        // CAS 3 : DÉFAITE
        else {
            if (partie->vies > 0) {
                effacerEcran();
                changerCouleur(COULEUR_ROUGE);
                printf("\n\n    IL VOUS RESTE %d VIES. RECOMMENCEZ !\n", partie->vies);
                Sleep(2000);
                genererNiveau(partie, partie->niveau); // On recommence le même niveau
            } else {
                effacerEcran();
                changerCouleur(COULEUR_ROUGE);
                printf("\n\n    GAME OVER FINAL\n");
                Sleep(2000);
            }
        }
    }
}

// === BOUCLE DE JEU (TEMPS RÉEL) ===
// Source : Assistant IA (Structure de boucle non-bloquante complexe)
// Rôle : C'est le Moteur MUX. Il gère le timer, les inputs clavier et l'affichage simultanément.
// Entrée : La structure Partie.
// Sortie : 1 (Gagné), 0 (Perdu), -1 (Abandon).
int jouerNiveau(Partie* partie) {
    int curseurX = 5, curseurY = 5; // Position de départ du curseur
    int selectX = -1, selectY = -1; // Aucune sélection au début (-1)
    int partieEnCours = 1;
    unsigned char touche;
    int resultatNiveau = 0;

    // Initialisation du Chronomètre
    clock_t debutNiveau = clock();
    int tempsInitial = partie->temps_restant;
    int tempsAffiche = tempsInitial;

    afficherNiveauJeu(partie, curseurX, curseurY, selectX, selectY);

    while (partieEnCours) {

        // 1. GESTION DU TEMPS (Calcul des secondes écoulées)
        clock_t now = clock();
        double tempsPasse = ((double)(now - debutNiveau)) / CLOCKS_PER_SEC;
        partie->temps_restant = tempsInitial - (int)tempsPasse;
        if (partie->temps_restant < 0) partie->temps_restant = 0;

        int actionClavier = 0;

        // 2. GESTION DU CLAVIER (Non bloquant avec kbhit)
        if (kbhit()) {
            touche = getch();
            actionClavier = 1;

            // Gestion des flèches directionnelles (codes spéciaux)
            if (touche == 224) {
                touche = getch();
                switch (touche) {
                    case 72: if (curseurY > 0) curseurY--; break; // Haut
                    case 80: if (curseurY < HAUTEUR - 1) curseurY++; break; // Bas
                    case 75: if (curseurX > 0) curseurX--; break; // Gauche
                    case 77: if (curseurX < LARGEUR - 1) curseurX++; break; // Droite
                }
            } else {
                switch (touche) {
                    case 27: // TOUCHE ECHAP
                        // On met en pause implicitement car on attend une saisie
                            allerA(0, HAUTEUR + 10); // On écrit en bas de l'écran
                    changerCouleur(COULEUR_JAUNE);
                    printf("Voulez-vous sauvegarder et quitter ? (O/N) : ");

                    char reponse = getch();
                    if (reponse == 'o' || reponse == 'O') {
                        char pseudoSauvegarde[50];
                        changerCouleur(COULEUR_CYAN);
                        printf("\nEntrez votre pseudo : ");
                        changerCouleur(COULEUR_BLANC);

                        // On réutilise ta fonction de saisie
                        saisirPseudo(pseudoSauvegarde, 50);

                        // On sauvegarde TOUT (Plateau, Timer, Contrat...)
                        if(sauvegarderPartieComplete(pseudoSauvegarde, partie)) {
                            printf("\nPartie sauvegardee avec succes ! A bientot.");
                        } else {
                            printf("\nErreur de sauvegarde !");
                        }
                        Sleep(1000);
                        partieEnCours = 0;
                        resultatNiveau = -1; // -1 pour dire qu'on quitte
                    }
                    else {
                        // Si on répond Non, on efface le message et on continue à jouer
                        // (Optionnel : il faudrait redessiner le bas de l'écran proprement)
                        afficherNiveauJeu(partie, curseurX, curseurY, selectX, selectY);
                    }
                    break;

                    case 'z': case 'Z': if (curseurY > 0) curseurY--; break;
                    case 's': case 'S': if (curseurY < HAUTEUR - 1) curseurY++; break;
                    case 'q': case 'Q': if (curseurX > 0) curseurX--; break;
                    case 'd': case 'D': if (curseurX < LARGEUR - 1) curseurX++; break;

                    case ' ': // ESPACE (Sélection)
                        if (selectX == -1) {
                            // Première sélection
                            selectX = curseurX;
                            selectY = curseurY;
                        } else {
                            // Deuxième sélection : Tentative d'échange
                            if (estAdjacent(selectY, selectX, curseurY, curseurX)) {
                                permuterItems(partie, selectY, selectX, curseurY, curseurX);
                                gererMatchsEtCascades(partie); // On lance la réaction en chaîne
                            } else {
                                allerA(0, 35);
                                afficherMessageTemporaire("Mouvement impossible : Cases non adjacentes !");
                                getch();
                            }
                            // On réinitialise la sélection
                            selectX = -1; selectY = -1;
                        }
                        break;
                }
            }
        }

        // 3. VÉRIFICATION DES CONDITIONS DE FIN
        int victoire = verifierVictoire(partie);

        if (victoire) {
            if(!actionClavier) afficherNiveauJeu(partie, curseurX, curseurY, selectX, selectY);
            Sleep(500);
            partieEnCours = 0;
            resultatNiveau = 1;
        } else if (partie->coups_restants <= 0 || partie->temps_restant <= 0) {
            // Défaite
            if(!actionClavier) afficherNiveauJeu(partie, curseurX, curseurY, selectX, selectY);
            partie->vies--;
            afficherDefaite();
            getch();
            partieEnCours = 0;
            resultatNiveau = 0;
        }

        // 4. RAFRAÎCHISSEMENT DE L'ÉCRAN
        // Si le temps a changé, on met à jour juste le timer (Optimisation)
        if (partieEnCours && !actionClavier && partie->temps_restant != tempsAffiche) {
            tempsAffiche = partie->temps_restant;
            rafraichirTimerSeulement(partie);
        }
        // Si le joueur a bougé, on redessine tout
        if (actionClavier && partieEnCours) {
            afficherNiveauJeu(partie, curseurX, curseurY, selectX, selectY);
        }

        Sleep(10); // Petite pause pour ne pas surcharger le processeur
    }
    
    return resultatNiveau; 
}
